18/11/2021 - 1:40
The process of implementing the shortest superstring is being quite the
mental challenge. 

I ended up figuring out (another) weird solution. By abstracting the inputs
into a Sequence object, a tree-like structure was created. Each Sequence
object has a parent(Sequence*), a sequence(string), an include(int), and
a derivations(vector<Sequence*>). It's some sort of multi-tree structure.
The include attribute is an integer which stands for how many atomic strings
that particular sequence includes. The goal then becomes finding a sequence
in which include == in.size().

To do this we're trying to apply a brute-force algorithm into in some sort
of abstract recursion manner. We came very close to hitting the mark on a
solution, but unfortunatelly forgot to account for the need of the cleanUp
method, which eliminates redundant sequences, to have in increment in powers
of two: by first generation sequences which have an include = 2 are redundant,
since they only include those strings which formed them. For second generation
strings, include = 4 signifies redundancy, and so on and so forth.

This small mistake made the algorithm fall into the infinite recursion trap.
Unfortunately, by the time we noticed this slip, it was already too late, and 
another different solution was being implemented. Since a VCS wasn't properly 
used, the mental effort to rebuild the previous solution was too big of an
increment, therefore it was chosen to comment about what was going on, about
the said need for a power of 2 counter, and the document was closed.

Hopefully tomorrow, with a fresh head, the solution will be easier to implement.
In spite of the roadblocks and landslides, it feels like a very strong solu-
tion, which combines objects and recursion in a very innovative way, at least
for the unexperienced eyes of this developer. The process of figuring out how 
to reduce possible keys by eliminating redundancy was quite interesting. Coding
in that abstract-recursion paradigm was also quite the challenge - keeping
track of how the tree would branch out while coding it, and trying to fit
different layers of stop conditions dynamically was almost brain melting, which
means we're on the right track to get better.

Now for some relaxation - ended up not stuyding anything else the whole day.
Fortunately almost everything is up to date, and there's no swamping or flooding
in any form of way. Let's try to keep it this way for as long as possible, so
we can go through the experience of grinding away at these weekly challenges.

Cheers!
- Pedro Barbeira



19/11/2021 - 12:40
Ended up following the greedy algorithm that calculates the best concatenation and
does it over and over. To be honest, the multi tree structure, while conceptually
interesting, felt like just a bit out of reach for me yet. I'd rather learn the
traditional structures and get used to them before starting to implement some weird
flipped-out versions to solve particular problems. Either way, the process of thinking
through it was done, so it's not like there's no conceptual gains at all.

The big takeaway from this week is to be smart about solving problems. It's not just
about pure brainpower - it's also about finding the shortcuts. In this case, finding
the shortcut was researching the problem and reading about what was going on around
it. Considering the emphasis on the Painter's Partition, I believe that was what they
were trying to get to us. What added up to some long hours of concentrated thinking
could've been solved by 15 minutes searching Google. The long hours could've been
spent improving the existing solution.

Either way, turning concepts on their head is a skill in its own, and the fractal
thinking required to think through the multi tree solution will certainly be a
valuable skill in the future.

Finally, it was decided to leave the Mooshak problems as a fun after-study. They're
being very mind expanding and interesting, but I'm starting to get flooded. Spending
6 hours trying to solve a problem is in no way productive. I'll focus on handling
the school work first, and when I feel the grip on the material is tight enough for
the time being I'll proceed to hack away at the Mooshak exercises.

Overall it was a nice week, with many valuable lessons. Let's keep the ball rolling.
I definitely feel more "coder" at this point, which is great. Not top of the class,
but not bottom either. High-mid tier is good enough for me. I'll hold on to my
creative outlook and ability to conjure up complex systems, but will try to keep it
in store for now. It's important to make sure this ability doesn't make things harder
then they have to be. The focus should always be to arrive at the simplest solution
possible. The complexity will arise on it's own. Having the tools to handle it is a
blessing, one that should be treasured and honed as such.

Cheers!
-Pedro Barbeira
